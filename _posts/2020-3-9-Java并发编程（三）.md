---
title: JVM并发编程（三）Lock与Condition
key: 20200313
tags: Java Concurrency
---

## Java并发编程（一）Lock与Condition

### Lock基本原理

Lock是一个接口，其定义如下：

```java
public interface Lock {
    void lock();
    void lockInterruptibly() throws InterruptedException;
    boolean tryLock();
    boolean tryLock(long time, TimeUnit unit) throws InterruptedException;
    void unlock();
    Condition newCondition();
}
```

常用的方法是lock()和unlock()。lock()不能被中断，对应的lockInterruptibly()可以被中断。

ReentrantLock本身没有逻辑，实现都在内部Sync中。

```java
public class ReentrantLock implements Lock , java.io.Serializable{
    private final Sync sync;
    public void lock() {
        sync.lock();
    }
    public void unlock() {
        sync.unlock();
    }
}
```

Sync的父类AbstractQueuedSynchronizer经常被称为队列同步器(AQS)，这个类非常关键。Atomic类都是“自旋”性质的锁，而在这篇文章中讲的锁都具备synchronized功能，也就是可以阻塞一个线程。该类的父类是abstractOwnableSynchronizer。为了实现一把具有阻塞或者唤醒功能的锁，需要以下几个核心要素：

1. 需要一个state变量，标记锁的状态。state变量的操作，要保证线程安全，也就是会使用到CAS。

2. 需要记录当前是哪个线程持有锁。

3. 需要底层支持对一个线程进行阻塞或唤醒操作。

4. 需要一个队列维护所有阻塞的线程。这个队列必须也是线程安全的无锁队列，也需要用到CAS。

针对要素1和2，有以下实现：

```java
public abstract class AbstractOwnableSynchronizer{
    ...
    private transient Thread exclusiveOwnerThread;//记录锁被哪个线程所持有
}

public abstract class AbstractOwnableSynchronizer extends AbstractOwnableSynchronizer{
    private volatile int state; //记录锁的状态，通过CAS修改state值
}
```

state的取值不仅仅可以表示0和1，还可以大于1，就是为了支持锁的可重入性。当state = 0时，没有线程持有锁，exclusiveOwnerThread = null。当state = 1 时，有一个线程持有锁，exclusiveOwnerThread等于该线程。 当state > 1 时，说明该线程冲入了该锁。

针对要素3，在Unsafe类中，提供了阻塞或唤醒线程的一对操作原语，也就是park()和unpark()。

```java
public native void unpark(Object var1);
public native void park(boolean var1, long var2);
```

然后一个LockSupport的工具类，对这两个原语进行简单的封装。

```java
public class LockSupport{
    ...
    public static void park(){
        UNSAFE.park(false, 0);
    }
    public static void unpark(Thread thread){
        if(thread != null){
            UNSAFE.unpark(thread);
        }
    }
}
```


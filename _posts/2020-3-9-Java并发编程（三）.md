---
title: JVM并发编程（三）Lock与Condition
key: 20200313
tags: Java Concurrency
---

## Java并发编程（一）Lock与Condition

### Lock基本原理

Lock是一个接口，其定义如下：

```java
public interface Lock {
    void lock();
    void lockInterruptibly() throws InterruptedException;
    boolean tryLock();
    boolean tryLock(long time, TimeUnit unit) throws InterruptedException;
    void unlock();
    Condition newCondition();
}
```

常用的方法是lock()和unlock()。lock()不能被中断，对应的lockInterruptibly()可以被中断。

ReentrantLock本身没有逻辑，实现都在内部Sync中。

```java
public class ReentrantLock implements Lock , java.io.Serializable{
    private final Sync sync;
    public void lock() {
        sync.lock();
    }
    public void unlock() {
        sync.unlock();
    }
}
```

Sync的父类AbstractQueuedSynchronizer经常被称为队列同步器(AQS)，这个类非常关键。Atomic类都是“自旋”性质的锁，而在这篇文章中讲的锁都具备synchronized功能，也就是可以阻塞一个线程。该类的父类是abstractOwnableSynchronizer。为了实现一把具有阻塞或者唤醒功能的锁，需要以下几个核心要素：

1. 需要一个state变量，标记锁的状态。state变量的操作，要保证线程安全，也就是会使用到CAS。

2. 需要记录当前是哪个线程持有锁。

3. 需要底层支持对一个线程进行阻塞或唤醒操作。

4. 需要一个队列维护所有阻塞的线程。这个队列必须也是线程安全的无锁队列，也需要用到CAS。

针对要素1和2，有以下实现：

```java
public abstract class AbstractOwnableSynchronizer{
    ...
    private transient Thread exclusiveOwnerThread;//记录锁被哪个线程所持有
}

public abstract class AbstractOwnableSynchronizer extends AbstractOwnableSynchronizer{
    private volatile int state; //记录锁的状态，通过CAS修改state值
}
```

state的取值不仅仅可以表示0和1，还可以大于1，就是为了支持锁的可重入性。当state = 0时，没有线程持有锁，exclusiveOwnerThread = null。当state = 1 时，有一个线程持有锁，exclusiveOwnerThread等于该线程。 当state > 1 时，说明该线程冲入了该锁。

针对要素3，在Unsafe类中，提供了阻塞或唤醒线程的一对操作原语，也就是park()和unpark()。

```java
public native void unpark(Object var1);
public native void park(boolean var1, long var2);
```

然后一个LockSupport的工具类，对这两个原语进行简单的封装。

```java
public class LockSupport{
    ...
    public static void park(){
        UNSAFE.park(false, 0);
    }
    public static void unpark(Thread thread){
        if(thread != null){
            UNSAFE.unpark(thread);
        }
    }
}
```

在当前线程中调用park()，该线程就会被阻塞；在另外一个线程中，调用unpark(Thread t)，传入一个被阻塞的线程，就可以唤醒阻塞在park()地方的线程。尤其是unpark(Thread t)，它实现了一个线程对另一个线程的精确唤醒。而notifty()只是唤醒某一个线程，而无法具体唤醒某一个线程。
针对要素4，在AQS中利用了一个双向链表和AQS实现了一个阻塞队列:

```java

public abstract class AbstractQueuedSynchronizer{
    ...
    static final class Node{
        volatile Thread thread;
        volatile Node next;
        volatile Node prev;
        ...
    }
    private transient volatile Node head;
    private transient volatile Node tail;
    ...
}
```

通过这个双链表往其中不断添加阻塞的线程。

### 公平性分析

下面基于AQS， ReentrantLock在公平性和非公平性上实现的差异。

```java

final static class NonfairSync extends Sync{
    ...
    final void lock() {
        if(compareAndSet(0,1)){ //一上来就尝试修改state值，也就是抢锁，不考虑队列中有没有其他线程在排队，是非公平的
            setExclusiveOwnerThread(Thread.currentThread());
        }else{
            acquire(1);
        }
    }
    ...
}

final static class FairSync extends Sync{
    ...
    final void lock() {
        acquire(1);
    }
    ...
}

```

acquire()是AQS的一个模板方法

```java

public final void acquire(int arg){
    if(!tryAcquire(arg) && acquireQueued(addWaiter(Node.EXCLUSIVE), arg)){
        selfInterrupt();
    }
}

```

tryAcquire()是一个虚函数，也就是再次尝试拿到锁，被NonfairSync与FairSync分别实现，下面看看他们有什么区别:

```java

abstract static class Sync extends AbstractQueuedSynchronizer {
    final boolean nonfairTryAcquire(int acquires) {
        final Thread current = Thread.currentThread();
        int c = getState();
        if (c == 0) {//无人持有锁，那么开始抢锁
            if (compareAndSetState(0, acquires)) {
                setExclusiveOwnerThread(current);
                return true;
            }
        }
        else if (current == getExclusiveOwnerThread()) {
            int nextc = c + acquires;
            if (nextc < 0) // overflow
                throw new Error("Maximum lock count exceeded");
            setState(nextc);
            return true;
        }
        return false;
    }
}

static final class FairSync extends Sync{
    protected final boolean tryAcquire(int acquires) {
        final Thread current = Thread.currentThread();
        int c = getState();
        if (c == 0) {
            if (!hasQueuedPredecessors() &&
                compareAndSetState(0, acquires)) {
                setExclusiveOwnerThread(current);
                return true;
            }
        }
        else if (current == getExclusiveOwnerThread()) {
            int nextc = c + acquires;
            if (nextc < 0)
                throw new Error("Maximum lock count exceeded");
            setState(nextc);
            return true;
        }
        return false;
    }
}

```

两者相比，就是公平lock()多了一个if(!hasQueuedPredecessors())。意思就是当c == 0，(没有线程持有锁)，并且排队到队列的第一个时，才去抢锁，否则继续排队，这才叫“公平”。

---
title: 套接字listen与accept
key: 20200206
tags: 计算机网络
---
![1fZyZj.png](https://s2.ax1x.com/2020/02/09/1fZyZj.png)

## listen()队列剖析

  listen()：监听端口，用在 TCP连接 中的 服务器端 角色；

  listen()函数调用格式：

  int listen(int sockfd, int backlog);

内核会根据somaxconn和backlog的较小值设置accept queue的大小，如果想扩大accept queue的大小，必须要同时调整这两个参数。

## 监听套接字的队列

  对于一个调用listen()进行监听的套接字，操作系统会给这个套接字 维护两个队列；

1. 未完成连接队列 【保存连接用的】当客户端 发送tcp连接三次握手的第一次【syn包】给服务器的时候，服务器就会在未完成队列中创建一个 跟这个 syn包对应的一项。其实，我们可以把这项看成是一个半连接【因为连接还没建立起来呢】，这个半连接的状态会从LISTEN变成SYN_RCVD状态，同时给客户端返回第二次握手包【syn,ack】这个时候，其实服务器是在等待完成第三次握手；

2. 已完成连接队列 【保存连接用的】     当第三次握手完成了，这个连接就变成了ESTABLISHED状态，每个已经完成三次握手的客户端 都放在这个队列中作为一项；

## accept()函数

  accept()函数，就使用来 从 已完成连接队列 中 的队首【队头】位置取出来一项【每一项都是一个已经完成三路握手的TCP连接】，返回给进程；  如果已完成连接队列是空的呢？那么咱们这个范例中accept()会【休眠】等待，一直到已完成队列中有一项时才会被唤醒；   所以，从编程角度，我们要尽快的用accept()把已完成队列中的数据【TCP连接】取走  accept()返回的是个套接字，这个套接字就代表那个已经用三次握手建立起来的那个tcp连接，因为accept()是从 已完成队列中取的数据；换句话来说，我们服务器程序，必须要严格区分两个套接字：

1. 监听9000端口这个套接字，这个东西叫“监听套接字【listenfd】”，只要服务器程序在运行，这个套接字就应该一直存在；
2. 当客户端连接进来，操作系统会为每个成功建立三次握手的客端再创建一个套接字【当然是一个已经连接套接字】，accept()返回的就是这种套接字；*

   也就是从已完成连接队列中取得的一项。随后，服务器使用这个accept()返回的套接字和客户端通信的；*

## syn攻击【syn flood】

攻击者发送TCP SYN，SYN是TCP三次握手中的第一个数据包，而当服务器返回ACK后，该攻击者就不对其进行再确认，那这个TCP连接就处于挂起状态，也就是所谓的半连接状态，服务器收不到再确认的话，还会重复发送ACK给攻击者。这样更加会浪费服务器的资源。攻击者就对服务器发送非常大量的这种TCP连接，由于每一个都没法完成三次握手，所以在服务器上，这些TCP连接会因为挂起状态而消耗CPU和内存，最后服务器可能死机，就无法为正常用户提供服务了。也称DDOS攻击



 
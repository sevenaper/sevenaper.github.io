---
title: JVM并发编程（四）并发容器
key: 20200317
tags: Java Concurrency
---

## Java并发编程（四）并发容器

### BlockingQueue

BlockingQueue是一个带阻塞功能的队列。当入队列时如果队列已满，那么阻塞调用者，当出队列时如果队列为空，同样会阻塞调用者。

```java
public interface BlockingQueue<E> extends Queue<E>{
    ...
    boolean add(E e);
    boolean offer(E e);
    void put(E e) throws InterruptedException; //阻塞
    E take() throws InterruptedException; //阻塞
    ...
}
```

#### ArrayBlockingQueue

ArrayBlockingQueue是一个数组实现的环形队列，构造函数会要求传入数组的容量。

```java
public class ArrayBlockingQueue<E> extends AbstractQueue<E>
        implements BlockingQueue<E>, java.io.Serializable {


    /** The queued items */
    final Object[] items;

    /** items index for next take, poll, peek or remove */
    int takeIndex;

    /** items index for next put, offer, or add */
    int putIndex;

    /** Number of elements in the queue */
    int count;

    /*
     * Concurrency control uses the classic two-condition algorithm
     * found in any textbook.
     */

    /** Main lock guarding all access */
    final ReentrantLock lock;

    /** Condition for waiting takes */
    private final Condition notEmpty;

    /** Condition for waiting puts */
    private final Condition notFull;
}
```

#### LinkedBlockingQueue

LinkedBlockingQueue是一种基于单项列表的阻塞队列。因为队头和队尾是2个指针分开操作的，所以使用了2把锁和2个条件，同时有一个AtomicInteger的原子变量记录count数。

```java
public class LinkedBlockingQueue<E> extends AbstractQueue<E>
        implements BlockingQueue<E>, java.io.Serializable {

    static class Node<E> {
        E item;

        /**
         * One of:
         * - the real successor Node
         * - this Node, meaning the successor is head.next
         * - null, meaning there is no successor (this is the last node)
         */
        Node<E> next;

        Node(E x) { item = x; }
    }

    /** The capacity bound, or Integer.MAX_VALUE if none */
    private final int capacity;

    /** Current number of elements */
    private final AtomicInteger count = new AtomicInteger();

    /**
     * Head of linked list.
     * Invariant: head.item == null
     */
    transient Node<E> head;

    /**
     * Tail of linked list.
     * Invariant: last.next == null
     */
    private transient Node<E> last;

    /** Lock held by take, poll, etc */
    private final ReentrantLock takeLock = new ReentrantLock();

    /** Wait queue for waiting takes */
    private final Condition notEmpty = takeLock.newCondition();

    /** Lock held by put, offer, etc */
    private final ReentrantLock putLock = new ReentrantLock();

    /** Wait queue for waiting puts */
    private final Condition notFull = putLock.newCondition();
}
```

为了提高并发度，用了两把锁，分别控制队头、队尾的操作。意味着take()和take()，put()和put()之间互斥，但是take()和put()并不互斥。

#### PriorityBlockingQueue

和ArrayBlockingQueue实现类似，主要是用数组实现了一个二叉堆。

#### DelayQueue


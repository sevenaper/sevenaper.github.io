---
title: JVM并发编程（一）
key: 20200306
tags: Java Concurrency
---

## Java并发编程（一）

### 守护线程

JVM运行过程中，所有非守护进程退出后，整个JVM进程就会退出。所以下列代码在main函数退出后，线程t1并不会退出。但是如果将t1设置成守护线程，那么JVM进程就会退出。

```java
public class ThreadLearn {
    public static void main(String[] args) {
        System.out.println("main enter!");
        Thread t1 = new Thread(new Runnable() {
            @Override
            public void run() {
                while (true){
                    System.out.println("t1 is executing");
                    try {
                        Thread.sleep(500);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        });
        //t1.setDaemon(true);
        t1.start();
        System.out.println("main exit");
    }
}
```

### 轻重量级阻塞

实际上，只有那些声明了会抛出InterruptedException的函数才会抛出异常，也就是下面常用的函数:

```java
public static native void sleep(long milliseconds) throws InterruptedException{...}
public final void wait() throws InterruptedException{...}
public final void join() throws InterruptedException{...}
```

能够被中断的阻塞成为轻量级阻塞，对应的线程状态是WAITING或者TIMED_WAITING，而synchronized这种不能被中断的阻塞成为重量级阻塞，对应的状态为BLOCKED。
![UbA8v4.jpg](https://s1.ax1x.com/2020/07/22/UbA8v4.jpg)
在READY和RUNNING状态切换，是又操作系统的时间片调度算法完成。除了可以使用yield()函数，放弃对CPU的占用。

### synchronized关键字

```java
class A{
    public void synchronized f1(){...}
    public static void synchronized f2(){...}
}
```

等价于下列的代码

```java
class A{
    public void f1(){
        synchronized(this){...}
    }
    public static void f2{
        synchronized(A.class){...}
    }
}
```

对于非静态成员函数，锁加载对象a上面，对于静态成员函数，锁加载A.class上面。所以对于一个静态成员函数和一个非静态成员函数，都加synchronized关键字，它们是不互斥的。

---
title: NIO初探（一）
key: 201808015
tags: Java NIO
---

### 相关概要

##### 缓冲区(Buffers)

新的Buffer类是常规Java类和通道之间的纽带。原始数据元素组成的固定长度数组，封装在包含状态信息的对象中去，存入缓冲区。缓冲区提供了一个会合点：通道可提取放在缓冲区中的数据（写），也可想缓冲区存入数据供读取（读），还有一种特殊类型的缓冲区，用于内存映射文件。

##### 通道(Channels)

NIO新引入的最重要的的抽象是通道的概念。Channel对象模拟了通信连接，管道既可以是单向的，也可以是双向的。可以把通道想象成连接缓冲区和I/O服务的捷径。

某些情况下，软件包中的旧类可以利用通道。为了能够想与文字或套接字关联的通道进行存取，适当的地方都增加了新方法。

多数通道可工作在非块模式下，这意味着更好的可伸缩性，尤其是与选择器一同使用的时候。

##### 文件锁定和内存映射文件(File locking and memory-mapped files)

新的FileChannel对象包含在java.nio.channels软件包内，提供很多面向文件的新特性，其中最有趣的两个是文件锁定和内存映射文件。

再多个进程协同工作的情况下，要协调各个进程对共享数据的访问，文件锁定是必不可少的工具。

文件映射到内存，这样在您看来，磁盘上的文件数据就像是内存中一样。这里用了操作系统的虚拟内存功能，无需再内存中实际保留一份文件的拷贝，就可实现文件内容的动态高速缓存。

##### 套接字(Sockets)

套接字通道类为使用网络套接字实现交互提供了新方法。套接字通道可工作于非块模式，并可与选择器一同使用。因此，多个套接字可实现多路传输，管理效率也比java.net中提供的传统套接字效率更高。

##### 选择器(Selectors)

选择器可实现就绪性选择。Selector类提供了确定一或多个通道当前状态的机制。使用选择器，借助单一线程，就可以对数量庞大的活动I/O通道实施监控和维护。

##### 正则表达式(Regular expressions)

新的正则表达式API之所以被看成是NIO的组成部分，是因为JSR51把它与其他NIO特性放在一起做了详细说明。虽然它再很多方面与NIO的其他组成部分缺乏平行关系，但它再文件处理等众多领域都是极其有用的。

##### 字符集(Character sets)

java.nio.charsets提供了新类用于处理字符和字节流之间的映射关系。我们可以对字符转换映射方式进行选择，也可以自己创建映射。







### 从I/O谈起

##### I/O的重要性

![](http://p73rf095s.bkt.clouddn.com/18-8-15/55688875.jpg)

前三个行显示了处理阶段如何影响吞吐率。把单位处理时间减半，仅能提高吞吐率的2.2%。而另一方面，仅仅缩短I/O延迟10%，就可使吞吐率增加9.7%。影响程序执行效率的限定因素，往往并非处理速率，而是**I/O**。再I.O性能上的小小投入，就可以换来客观的汇报。

然而，在大多数情况下，Java应用程序并非真的受着I/O的束缚。操作系统并非不能快速传递，让Java有事可做；相反是JVM在I/O方面效率欠佳。操作系统与Java基于流的I/O模型有些不匹配。操作系统移动的是大块数据（缓冲区），这往往是再硬件直接存储器（DMA）协助下完成的。而JVM的I/O流数据类喜欢操作小块数据——单个字节、几行文本，结果操作系统送来整缓冲区的数据，java.io的流数据类再花大量时间把他们拆成小块。往往拷贝一个小块就要往返于几层对象。操作系统喜欢整卡车地送来数据，java.io类则喜欢一铲子一铲子地加工数据。有了NIO，就可以轻松地把一卡车数据备份到能直接使用的地方(ByteBuffer对象)。

JVM作为一把双刃剑，让Java程序员不再为操作系统环境的区别而烦恼，但是某些个性鲜明、功能强大的功能也被挡在门外。如果使用JNI(Java本地接口)，直接使用操作系统特性，那么就会被绑定在操作系统上。一旦有漏洞，还可能把JVM频繁出错甚至崩溃。如果作为操作系统开发商，可以在你的JVM中包含本地代码，以Java API地形式提供这些特性，但是这样做会违反所签署地相应协定。根据协议，只允许提供符合一致性要求的JVM。

##### I/O概念

为了理解NIO类如何模拟I/O函数，因此掌握操作系统层面的处理细节十分重要，这样才能理解新的I/O模型。以下概念十分的重要：

###### 缓冲区操作

缓冲区以及缓冲区如何工作，是所有I/O的基础。所谓的输入输出讲的无非是数据移进缓冲区或移出缓冲区。进行I/O操作，归结起来，就是向操作系统发出请求，让它要么把缓冲区内的数据排干（写），要么用数据把缓冲区填满（读）。下面这张图简单描述了数据从外部磁盘想运行中的进程内存区域移动的过程。进程使用read()系统调用，要求其缓冲区填满。内核随即向磁盘控制硬件发出命令，要求其从磁盘读取数据。磁盘控制器把数据直接写入内核内存缓冲区，这一步通过DMA完成，无需CPU协助。一旦磁盘控制器把缓冲区装满，内核即把数据从内核空间的临时缓冲区拷贝到进程执行read()调用时指定的缓冲区。

![](http://p73rf095s.bkt.clouddn.com/18-8-16/24487774.jpg)

###### 内核空间与用户控件

用户可能关键是常规进程所在的区域。JVM就是常规进程，驻守于用户控件。用户控件是非特权区域，比如在该区域执行的代码不能直接访问硬件设备。内核空间时操作系统所在的区域。内核代码有特别的权利：它能与设备控制器通讯，控制着用户区域的进程的运行状态。

当进程请求I/O操作的时候，它执行一个系统调用（有时称为陷阱）将控制权转交给内核。当内核这种方式被调用，它随机采取任何必要步骤，找到进程所需要的数据，并把数据传送到用户空间内的制定缓冲区。内核试图对数据进行高速缓存或预读取，因此进程所需数据可能已经在内核空间里。如果是这样，该数据只需简单地拷贝出来即可。如果数据不在内核空间，则进程被挂起，内核着手把数据都进内存。

之所以把数据从内核拷贝到用户空间，而不直接让磁盘控制器把数据送到用户空间的缓冲区，是因为硬件通常不能直接访问用户空间，并且像磁盘这种基于块存储的硬件操作设备的是固定大小的数据块，而用户进程请求的可能是任意大小或非对齐的数据块。在数据往来于用户空间与存储设备的过程中，内核负责数据的分解、再组合工作，因此充当着中间人的角色。

许多操作系统能把组装/分解过程进行得更加高效。根据发散/汇聚的概念，进程只需一个系统调用，就能把一连串缓冲区传递给操作系统。然后根据顺序填充或排干多个缓冲区，写的时候再从多个缓冲区把数据汇聚起来。

![](http://p73rf095s.bkt.clouddn.com/18-8-16/92116174.jpg)

###### 虚拟内存

虚拟内存是使用虚假地址取代物理内存地址。控制器不能通过DMA直接用户空间，但是通过虚拟内存，设备就可以填充对内核与用户空间进程可见的缓冲区。但前提条件是，内核与用户缓冲区必须使用相同的页对齐，缓冲区区的大小还必须是磁盘控制器大小的倍数。

###### 分页技术

现代CPU包含一个成为内存管理单元(MMU)的子系统，逻辑上位于CPU与物理内存之间。该设备包含虚拟地址向物理地址转换所需要的信息。当CPU引用某内存地址时，MMU负责确定该地址所在页，并将虚拟也好转化为屋里也好。如果当前不存在与该虚拟页形成有效映射的物理内存也，MMU会向CPU提交一个页错误。

###### 面向文件的I/O和流I/O

文件I/O

* 确定求情的数据分布在文件系统的哪些页。磁盘上的文件内容和元数据可能跨越多个文件系统页，而且这些页也可能不连续
* 由内核空间分配足够数量的内存页，以容纳得到确定的文件系统页
* 在内存也与磁盘上的文件系统页之间建立映射
* 为每一个内存页产生页错误
* 虚拟内存俘获页错误，安排页面调入，从磁盘上读取页内容，使页有效
* 一旦页面调入操作完成，文件系统即对原生数据进行解析，取得所需文件的内容或属性信息

流I/O：字节流必须顺序存取，常见有TTY设备、打印机端口和网络连接。速度一般也比块设备慢，经常用于间歇性输入。
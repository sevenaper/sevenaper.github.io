---
title: JVM初步探索（二）：Java对象解密
key: 20180902
tags: Java JVM
---

### 对象的创建

![](https://images2015.cnblogs.com/blog/592743/201603/592743-20160319235423381-1926278401.png)

虚拟机遇到一条new指令时，首先去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个类是否已被加载、解析和初始化过。如果没有，那么必须执行 相应的类加载过程。类加载过程检查通过后，接下来的虚拟机将会为新生对象分配内存。空间大小在类加载完成后即可完全确定。

如果Java堆中内存规整，采取**指针碰撞**方法来划分内存，即空闲和不空闲的内存由一个指针进行划分。分配内存就是指针向空闲方向移动一段与对象相等的距离。否则采用**空闲链表**的方式，也就是在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。

在高并发情况下，分配内存采用两种方法。一种是对分配内存的空间动作进行同步处理——实际上虚拟机采用CAS配上失败重试的方式保证操作的原子性；另一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存TLAB。那个现诚邀分配内存，就在哪个线程的TLAB中进行分配，只有在TLAB用完并分配新的TLAB时，才需同步锁定。

### 内存布局

对象头：

* 存储对象自身运行时的数据，如HashCode，GC分代年龄，锁状态标志，线程持有的锁，偏向线程ID，偏向时间戳。
* 类型指针指向对象的类元数据，虚拟机通过这个指针确定该对象是哪个类的实例。 数组之类的对象还会存储数组长度

![](https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=2471399057,1363437917&fm=27&gp=0.jpg)

实例数据：

存储在对象中的有效信息，Hotspot VM 相同长度的字段分配在一起 所以父类变量可能出现在子类之前。

对齐填充：保证对象大小是8个字节的整数倍。

### 访问定位

使用句柄：指向句柄池（保存实例对象的地址），通过句柄池找到引用对象：访问对象通过一个句柄指针一次间接索引之后，当对象实例数据被移动的时候(垃圾回收的时候有些对象会被移动)，只需要改变句柄池中该对象实例的地址即可，无需改变引用和句柄池的对应关系，所以引用中存储的是稳定的句柄地址。 

![](http://p73rf095s.bkt.clouddn.com/18-5-30/99057089.jpg)

直接指针：指针指向引用对象的内存区域：速度快

![](http://p73rf095s.bkt.clouddn.com/18-5-30/55601030.jpg)
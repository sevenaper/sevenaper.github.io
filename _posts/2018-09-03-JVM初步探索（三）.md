---
title: JVM初步探索（三）：垃圾回收算法
key: 20180903
tags: Java JVM

---

## 判断对象是否“死去”

### 引用计数法

给对象添加一个引用计数器，每当有一个地方引用它，计数值加1；引用失效时，计数值就减1；任何时刻计数值为0的对象就是不可能再背使用的。但是这种方法很难解决循环引用的问题。(Python Squirrel采用这种方法)

```java
public class ReferenceCountingGC
{
    public Object instance = null;
    private static final int _1MB = 1024 * 1024;
    private byte[] bigSize = new byte[2 * _1MB];

    public static void main(String[] args)
    {
        ReferenceCountingGC objA = new ReferenceCountingGC();
        ReferenceCountingGC objB = new ReferenceCountingGC();
        objA.instance = objB;
        objB.instance = objA;
        objA = null;
        objB = null;
        System.gc();
    }
}
```

运行结果发现发生了GC，所以JVM不是通过引用计数法判断对象是否存活。

### 可达性分析算法

通过成为"GC Roots"的对象作为起点，从这些节点开始向下搜索，搜所走过的路程称为引用链，当从GC Roots到这个对象不可达时，证明此对象是不可用的。

![](http://p73rf095s.bkt.clouddn.com/18-9-4/37325866.jpg)



在Java语言中，可作为GC Roots对象包括下面几种：

* 虚拟机栈（栈帧的本地变量表）中引用的对象
* 方法区中类静态属性引用的对象
* 方法区中常量引用的对象
* 本地方法中JNI引用的对象

### 引用再谈

jdk1.2之前，引用定义为：如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称为这块内存代表着一个引用。

jdk1.2之后，Java对引用的概念进行了扩充，分为强引用，软引用，弱引用，虚引用四种，引用强度依次减弱：



1.强引用：只要引用存在，垃圾回收器永远不会回收 。

```Java
Object obj = new Object(); //可直接通过obj取得对应的对象 如
obj.equels(new Object()); 
```

而这样 obj对象对后面new Object的一个强引用，只有当obj这个引用被释放之后，对象才会被释放掉，这也是我们经常所用到的编码形式。 

2.软引用：非必须引用，内存溢出之前进行回收 

```java
Object obj = new Object();
SoftReference<Object> sf = new SoftReference<Object>(obj);
obj = null;
sf.get();//有时候会返回null
```

这时候sf是对obj的一个软引用，通过sf.get()方法可以取到这个对象，当然，当这个对象被标记为需要回收的对象时，则返回null； 软引用主要用户实现类似缓存的功能，在内存足够的情况下直接通过软引用取值，无需从繁忙的真实来源查询数据，提升速度；当内存不足时，自动删除这部分缓存数据，从真正的来源查询这些数据。 

3.弱引用：第二次垃圾回收时回收 

```java
Object obj = new Object();
WeakReference<Object> wf = new WeakReference<Object>(obj);
obj = null;
wf.get();//有时候会返回null
wf.isEnQueued();//返回是否被垃圾回收器标记为即将回收的垃圾
```

弱引用是在第二次垃圾回收时回收，短时间内通过弱引用取对应的数据，可以取到，当执行过第二次垃圾回收时，将返回null。 弱引用主要用于监控对象是否已经被垃圾回收器标记为即将回收的垃圾，可以通过弱引用的isEnQueued方法返回对象是否被垃圾回收器标记。 

4.虚引用：垃圾回收时回收，无法通过引用取到对象值 

```java
Object obj = new Object();
PhantomReference<Object> pf = new PhantomReference<Object>(obj);
obj=null;
pf.get();//永远返回null
pf.isEnQueued();//返回是否从内存中已经删除
```

虚引用是每次垃圾回收的时候都会被回收，通过虚引用的get方法永远获取到的数据为null，因此也被成为幽灵引用。 虚引用主要用于检测对象是否已经从内存中删除。 

### 生存还是死亡

即使在可达性分析算法中不可达的对象，也并非是“非死不可”，它现在处于缓刑过程，要真正宣告一个对象的死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行第一次筛选，筛选条件是此时对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()已经被虚拟机调用过，虚拟机将这两种情况视为没有必要执行。

如果被判定为有必要执行finalize()方法，那么这个对象会放在一个叫做F-Queue队列中。finalize()方法是对象逃脱死亡命运的最后一次机会，稍后GC对F-Queue中的对象进行第二次小规模标记，如果对象要在finalize()中拯救自己——只要重新与引用链上任何一个关系建立关联即可，那么它就会被移除“即将回收的集合”。

```java
public class FinalizeEscapeGC
{
    public static FinalizeEscapeGC SAVE_HOOK = null;

    public void isAlive()
    {
        System.out.println("yes, I am still alive :)");
    }

    @Override
    protected void finalize() throws Throwable
    {
        super.finalize();
        System.out.println("finalize method executed!");
        FinalizeEscapeGC.SAVE_HOOK = this;
    }

    public static void main(String[] args) throws Throwable
    {
        SAVE_HOOK = new FinalizeEscapeGC();

        //对象第一次成功拯救自己
        SAVE_HOOK = null;
        System.gc();
        //因为finalize方法优先级很低，所以暂停0.5秒来等待它
        Thread.sleep(500);
        if (SAVE_HOOK != null)
        {
            SAVE_HOOK.isAlive();
        } else
        {
            System.out.println("no, I am dead :(");
        }

        //下面这段代码与上面的完全相同，但是这次自救却失败了，因为任何一个对象
        // 的finalize方法都只会被系统调用一次
        SAVE_HOOK = null;
        System.gc();
        //因为finalize方法优先级很低，所以暂停0.5秒来等待它
        Thread.sleep(500);
        if (SAVE_HOOK != null)
        {
            SAVE_HOOK.isAlive();
        } else
        {
            System.out.println("no, I am dead :(");
        }
    }
}
```

finalize()和C/C++中的析构函数并不相同，他的运行代价高，不确定性大，无法保证各个对象的调用顺序。因此建议不要使用。

### 回收方法区

在方法区中进行垃圾回收的效率较低，在堆中，尤其在新生代中，常规应用进行一次垃圾回收一般可以回收70%-95的空间，而永久代的垃圾收集效率远低于此。

永久代垃圾回收主要回收废弃常量和无用的类。判断废弃常量是，如果一个字符串"abc"已经进入常量池中，但是当前系统中的任何一个String对象叫做"abc"的，换句话说，就是没有任何String对象引用常量池中的"abc"常量，也没有其它方法引用这个字面量，如果发生垃圾回收的话，"abc"将会被清出常量池。

判断“废弃变量”方法要满足三个条件：1.该类所有实力已经被回收，也就是Java堆中不存在该类的任何实例。2.加载该类的ClassLoader已经被回收。3.该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

## 垃圾回收算法

### 标记-清除

这是最基础的收集算法，算法分为“标记”和“清除”两个阶段：

* 标记出所有需要回收的对象
* 标记完成后统一回收所有标记的对象

它的不足主要有两个：一个是效率问题，标记和清楚两个过程的效率都不高；第二个是容易产生大量不连续的内存碎片。

### 复制算法

将内存按容量分为大小相等的两部分，每次只是用其中一块。当这一块的内存用完了，就将还存活着的对象复制到另一块上面，然后再把已经使用过的内存空间一次清理掉。

现代的商业虚拟机都采用这种收集算法来回收新生代。由于IBM公司进行研究表明，新生代中的对象98%是“朝生夕死”的，所以将堆分成8:1:1的Eden和两个Survivor区。这样只有10%的内存空间会被浪费。

![](http://ifeve.com/wp-content/uploads/2014/07/young_gc.png)

当Survivor空间不足时，需要其他内存（这里指老年代）进行分配担保。

### 标记-整理算法

复制算法在对象存活率较高时效率较低，因为要进行较多的复制操作，所以老年代一般不采取这样的方法（老年代复制的时候复制操作多，但是整理时移动操作较少）。根据老年代的特点，提出标记-整理算法。标记-压缩算法首先还是“标记”，标记过后，将不用回收的内存对象压缩到内存一端，此时即可直接清除边界处的内存，这样就能避免复制算法带来的效率问题 。

![](https://img1.tuicool.com/36Bjy2u.jpg!web)

### 分代收集算法

一般是把堆分成新生代和老年代，根据各个年代采取最合适的收集算法。新生代采用复制算法，老年代采用标记-整理算法。

## HotSpot算法实现

### 枚举根节点

从可达性分析中从GC Roots节点找引用为例，可作为GC Roots的节点主要是全局性的引用与执行上下文中，如果要逐个检查引用，必然消耗时间。  另外可达性分析对执行时间的敏感还体现在GC停顿上，因为这项分析工作必须在一个能确保一致性的快照中进行——这里的“一致性”的意思是指整个分析期间整个系统执行系统看起来就行被冻结在某个时间点，不可以出现分析过程中对象引用关系还在不断变化的情况，该点不满足的话分析结果的准确性就无法得到保证。这点是导致GC进行时必须暂停所有Java执行线程的其中一个重要原因。  由于目前主流的Java虚拟机都是准确式GC，做一档执行系统停顿下来之后，并不需要一个不漏的检查执行上下文和全局的引用位置，虚拟机应当有办法得知哪些地方存放的是对象的引用。在HotSpot的实现中，是使用一组OopMap的数据结构来达到这个目的的。

### 安全点

在OopMap的协助下，HotSpot可以快速且准确的完成GC Roots的枚举，但可能导致引用关系变化的指令非常多，如果为每一条指令都生成OopMap，那将会需要大量的额外空间，这样GC的空间成本会变的很高。  实际上，HotSpot也的确没有为每条指令生成OopMap，只是在特定的位置记录了这些信息，这些位置被称为安全点（SafePoint）。SafePoint的选定既不能太少，以致让GC等待时间太久，也不能设置的太频繁以至于增大运行时负荷。所以安全点的设置是以让程序“是否具有让程序长时间执行的特征”为标准选定的。“长时间执行”最明显的特征就是指令序列的复用，例如方法调用、循环跳转、异常跳转等，所以具有这些功能的指令才会产生SafePoint。  对于SafePoint，另一个问题是如何在GC发生时让所有线程都跑到安全点在停顿下来。这里有两种方案：抢先式中断和主动式中断。抢先式中断不需要线程代码主动配合，当GC发生时，首先把所有线程中断，如果发现线程中断的地方不在安全点上，就恢复线程，让他跑到安全点上。现在几乎没有虚拟机实现采用抢先式中断来暂停线程来响应GC。  而主动式中断的思想是当GC需要中断线程的时候，不直接对线程操作，仅仅简单的设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起，轮询标志的地方和安全点是重合的另外再加上创建对象需要分配的内存的地方。  

### 安全区域

使用安全点似乎已经完美解决了如何进入GC的问题，但实际情况却并不一定，安全点机制保证了程序执行时，在不太长的时间内就会进入到可进入的GC的安全点。但是程序如果不执行呢？所谓的程序不执行就是没有分配cpu时间，典型的例子就是线程处于sleep状态或者blocked状态，这时候线程无法响应jvm中断请求，走到安全的地方中断挂起，jvm显然不太可能等待线程重新分配cpu时间，对于这种情况，我们使用安全区域来解决。  安全区域是指在一段代码片段之中，你用关系不会发生变化。在这个区域的任何地方开始GC都是安全的，我们可以把安全区域看做是扩展了的安全点。  当线程执行到安全区域中的代码时，首先标识自己已经进入了安全区，那样当在这段时间里，JVM要发起GC时，就不用管标识自己为安全区域状态的线程了。当线程要离开安全区域时，他要检查系统是否完成了根节点枚举，如果完成了，那线程就继续执行，否则他就必须等待，直到收到可以安全离开安全区域的信号为止。 


---
title: JVM初步探索（三）：垃圾收集器和内存分配策略
key: 20180903
tags: Java JVM

---

## 判断对象是否“死去”

### 引用计数法

给对象添加一个引用计数器，每当有一个地方引用它，计数值加1；引用失效时，计数值就减1；任何时刻计数值为0的对象就是不可能再背使用的。但是这种方法很难解决循环引用的问题。(Python Squirrel采用这种方法)

```java
public class ReferenceCountingGC
{
    public Object instance = null;
    private static final int _1MB = 1024 * 1024;
    private byte[] bigSize = new byte[2 * _1MB];

    public static void main(String[] args)
    {
        ReferenceCountingGC objA = new ReferenceCountingGC();
        ReferenceCountingGC objB = new ReferenceCountingGC();
        objA.instance = objB;
        objB.instance = objA;
        objA = null;
        objB = null;
        System.gc();
    }
}
```

运行结果发现发生了GC，所以JVM不是通过引用计数法判断对象是否存活。

### 可达性分析算法

通过成为"GC Roots"的对象作为起点，从这些节点开始向下搜索，搜所走过的路程称为引用链，当从GC Roots到这个对象不可达时，证明此对象是不可用的。

图图图图  图床好像出了点问题

在Java语言中，可作为GC Roots对象包括下面几种：

* 虚拟机栈（栈帧的本地变量表）中引用的对象
* 方法区中类静态属性引用的对象
* 方法区中常量引用的对象
* 本地方法中JNI引用的对象

### 引用再谈

jdk1.2之前，引用定义为：如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称为这块内存代表着一个引用。

jdk1.2之后，Java对引用的概念进行了扩充，分为强引用，软引用，弱引用，虚引用四种，引用强度依次减弱：



1.强引用：只要引用存在，垃圾回收器永远不会回收 。

```Java
Object obj = new Object(); //可直接通过obj取得对应的对象 如
obj.equels(new Object()); 
```

而这样 obj对象对后面new Object的一个强引用，只有当obj这个引用被释放之后，对象才会被释放掉，这也是我们经常所用到的编码形式。 

2.软引用：非必须引用，内存溢出之前进行回收 

```java
Object obj = new Object();
SoftReference<Object> sf = new SoftReference<Object>(obj);
obj = null;
sf.get();//有时候会返回null
```

这时候sf是对obj的一个软引用，通过sf.get()方法可以取到这个对象，当然，当这个对象被标记为需要回收的对象时，则返回null； 软引用主要用户实现类似缓存的功能，在内存足够的情况下直接通过软引用取值，无需从繁忙的真实来源查询数据，提升速度；当内存不足时，自动删除这部分缓存数据，从真正的来源查询这些数据。 

3.弱引用：第二次垃圾回收时回收 

```java
Object obj = new Object();
WeakReference<Object> wf = new WeakReference<Object>(obj);
obj = null;
wf.get();//有时候会返回null
wf.isEnQueued();//返回是否被垃圾回收器标记为即将回收的垃圾
```

弱引用是在第二次垃圾回收时回收，短时间内通过弱引用取对应的数据，可以取到，当执行过第二次垃圾回收时，将返回null。 弱引用主要用于监控对象是否已经被垃圾回收器标记为即将回收的垃圾，可以通过弱引用的isEnQueued方法返回对象是否被垃圾回收器标记。 

4.虚引用：垃圾回收时回收，无法通过引用取到对象值 

```java
Object obj = new Object();
PhantomReference<Object> pf = new PhantomReference<Object>(obj);
obj=null;
pf.get();//永远返回null
pf.isEnQueued();//返回是否从内存中已经删除
```

虚引用是每次垃圾回收的时候都会被回收，通过虚引用的get方法永远获取到的数据为null，因此也被成为幽灵引用。 虚引用主要用于检测对象是否已经从内存中删除。 

### 生存还是死亡


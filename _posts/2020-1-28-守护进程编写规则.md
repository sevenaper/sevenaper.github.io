---
title: 守护进程编写规则
key: 20200128
tags: Linux
---

1. 首先要调用umask将文件模式创建屏蔽字设置为一个已知值（通常是0）。由继承的来的文件模式创建屏蔽字可能会被设置为拒绝某些权限。如果守护进程要创建文件，那么它可能要设置的特定的权限
2. 调用fork，然后使父进程exit。这样做实现了下面几点了第一，如果该守护进程是作为一条简单的shell命令启动的，那么父进程终止会让shell认为这条命令已经执行完毕。第二，锐然子进程继承了父进程的进程组ID，但获得了一个新的进程ID，这就保证了子进程不是一个进程组的组长进程
3. 调用setsid创建一个新会话。使调用进程：（a）成为新会话的首进程，（b）成为一个新进程组的组长进程，（c）没有控制终端
4. 将当前工作目录更改为跟目录。从父进程处继承过来的当前工作目录可能在一个挂载的文件系统中。因为守护进程通常在系统再引导之前是一直存在的，所以如果守护进程的当前工作目录在一个挂载的文件系统中，那么该文件系统就不能被卸载
5. 关闭不需要的文件描述符。这使守护进程不再持有从父进程继承来的任何文件描述符（父进程可能是shell进程，或某个其他进程）
6. 某些守护进程打开/dev/null使其具有文件描述符0、1和2，这样，任何一个试图读标准输入、写标准输出或标准错误的库例程都不会产生任何效果。因为守护进程并不与终端设备相关联，所以其输出无处显示，也无处从交互式用户那里接受输入。即使守护进程是从交互式会话启动的，但是守护进程是在后台运行的，所以登陆会话的终止并不影响守护进程。如果其他用户在同一终端设备上登陆，我们不希望在该终端上见到守护进程的输出，用户也不期望他们在终端上的输入被守护进程读取

> 注：守护进程不接受来自内核的SIGUP ，SIGINT , SIGWINCH信号，很多守护进程把它作为通知信号，表示配置文件已经发生改变，守护进程应该重新读入其配置文件


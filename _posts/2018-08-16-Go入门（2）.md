---
title: Golang入门（二）：程序结构
key: 201808016
tags: Golang
---

### 名称

Go中函数、变量、常量、类型、语句标签和包的名称遵循一个简单的规则：名称的开头是一个字母(Unicode中的字符即可)或下划线，后面可以跟任意数量的字符、字符或下划线，并区分大小写。

> Go保留关键字：break   default   func   interface   select   case    defer    go    map    struct    chan    else    goto    package    switch    const    fallthrough    if    range    type    continue    for    import    return    var

如果一个实体只在函数中声明，它只在函数局部有效。如果声明在函数外，将对暴力所有源文件可见。实体第一个字母的大小写决定其是否可见性跨包。大写的话，意味着可以背包外的其他程序所引用。包名本身总是由小写字母构成的。Go命名风格采用“驼峰式”。

### 声明

Go程序存储在一个或多个以.go为后缀的文件里。每一个文件以package生命开头，表明文件属于哪个包。package声明后面是import声明，然后也是包级别的类型、变量、常量、函数的声明，不区分顺序。

```
package main
import "fmt"
const boilingF = 212.0
func main() {
	var f = boilingF
	var c = (f - 32) * 5 /9
	fmt.Printf("boiling point = %g°F or %g °C"，f,c)
}
```

常量boilingF是一个包级别的声明(main包)，f和c属于main函数的局部变量。包级别的尸体名字不仅对于包含其声明的源文件可见，而且对于同一个包的所有源文件都可见。

函数声明包含一个名字、一个参数列表、一个可选的返回值列表以及函数体。如果函数不返回任何内容，返回值列表可以省略。

### 变量

var声明创建一个具体类型的变量，然后给它附加一个名字，设置它的初始值。

```go
var name type = expression
```

类型和表达式部分可以省略一个，但是不能都省略。如果类型省略，它的类型将由初始化表达式决定；如果表达式省略，其初始值对应于类型的0值。

可以声明一个变量列表，并选择使用对应的表达式值列表对其初始化。忽略类型允许声明多个不同类型的变量。

```go
var i,j,k int
var b,f,s = true,2.3,"four"
```

##### 短变量声明

在**函数**中，一种称作短变量声明的可选性是可以用来声明和初始化**局部变量**，它使用name:expression的形式，name的类型由expression的类型来决定。

```go
anim := gif.Gif{LoopCount: nframes}
freq := rand.Float64() * 3.0
t := 0.0
```

var声明通常是因为那些跟初始化表达式类型不一致的局部变量保留的，或者用于后面才对变量赋值以及变量初始值不重要的情况。记住，:=表示声明，而=表示复制。一个变量的声明不能和多重复制搞混。

在下列代码中，第一条语句生命了in和err。第二条语句仅声明了out，但向已有的err变量赋了值。短变量最少声明一个新变量，否则编译无法通过。

##### 指针

如果一个变量声明为var x int，表达式&x(x的地址)获取一个指向整形变量的指针，它的类型是整形指针(*int)。

```go
x := 1
p := &x //p是整形指针，指向x
fmt.Println(*p) //"1"
*p = 2 
fmt.Println(x) //"2" 
```

指针类型的零值是nil。如果该指针不等于nil，那么p指向一个变量。例如在下面代码中，通过f产生的函数局部变量v调用返回后依然存在。

```go
func f() *int {
	v := 1
	return &v
}
func main() {
	fmt.Println(f() == f())//"false"
}
```

这是因为分配给变量的地址并不相同。

```go
func main() {
	fmt.Println(f())"0xc04200e098"
	fmt.Println(f())"0xc04200e0d0"
}
```



##### new函数

除此之外，new也可以来创建一个具有唯一地址的不同变量。

```go
func main() {
	p := new(int)
	q := new(int)
	fmt.Print(p == q)
}
```

~~但是这有一个例外，两个变量的类型不携带任何信息且是零值，例如struct{}和[0]int。~~经过证实，到现在golang 1.10.3版本中，例子中的地址分配已经不同。

```go
func main() {
	p := new([0]int)
	q := new([0]int)
	fmt.Print(p == q)//"false"
}

```

##### 变量的生命周期

判断垃圾是否可以回收可以用类似hotspot中的可达性分析法，选一作为GCRoot，根据引用链向下走，如果不能走到，那么判断其为垃圾。

### 包和文件

包让我们通过控制变量在包外的可见性或到处情况来隐藏信息。在Go里，通过一条简单的规则来管理标识符是否对外可见：导出的标识符以大写字母开头。	

golang的初始化顺序：

* 在 main 包中的 go 文件默认总是会被执行
* 同包下的不同 go 文件，按照文件名“从小到大”排序顺序执行
* 其他的包只有被 main 包 import 才会执行，按照 import 的先后顺序执行
* 被递归 import 的包的初始化顺序与 import 顺序相反，例如：导入顺序 main –> A –> B –> C，则初始化顺序为 C –> B –> A –> main
* 一个包被其它多个包 import，但只能被初始化一次

- main 包总是被最后一个初始化，因为它总是依赖别的包
- 避免出现循环 import，例如：A –> B –> C –> A
- 在同一个文件中，常量、变量、init()、main() 依次进行初始化

包的初始化在依赖已经解析完毕的情况下，根据依赖顺序进行。对于包级别的每一个变量，生命周期从其初始化开始。但是对于不能简单设置初始化值的变量，使用init函数。包的初始化按照在程序中导入的顺序来，以来顺序优先，每次初始化一个包。因此p导入包q，会保证q在p之前已经完全初始化。

